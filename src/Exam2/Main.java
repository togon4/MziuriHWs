package Exam2;

//import static Exam2.Factorial.factorial;
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
//        Scanner scanner = new Scanner();
        // 1 - ა
        // 2 - ა
        // 3 - ა
        // 4 - მეთოდის ხელწერა არის მისი დასახელებისა და მისი პარამტრების ტიპებისა და რაოდენობისაგან შემდგარი კონსტრუქცია
        // 5 - გ
        // 6 - რეკურსია არის ტექნიკა სადაც ფუნქცია იძახებს თავის პრობლემას და გაადააქცევს მას უფრო ადვილად გასასწორებელ პრობლემად.
        // 7
//        int number = 3;
//        System.out.println("Factorial of "+ number + "is "+ factorial(number));
        // 8 - ენკაპსულაცია- მონაცემთა ველების შეფუთვა, მეთოდები რომლებიც მოქმედებენ მონაცემებზე მხოლოდ ერთ კლასში ასევე მას ეკუთვნის მოდიფიკაციები private და protected, პოლიმორფიზმი- გადაფაროს სხვა კლასის მეთოდები, ინჰერითენსი- მემკვიდრეობა, ანუ sub da super კლასები, აბსტრაქცია- შეიქმნას აბსტრაქტული კლასები და ინტერფეისები რომლების საშუალებითაც შესაძლებელია დეტალების დამალვა და მხოლოდ არსებითი მახასიათებლების ჩვენება.
        // 9 - დ
        // 10 - დ
        // 11 - overloading - მეთოდის გადატვირთვა, ხდება მაშინ როცა ერთ კლასს აქვს ორი ერთნაირი მეთოდი, ერთნაირი სახელით და პარამეტრებით. overriding - როდესაც sub კლასი იღებს რაიმე მეთოდს მშობელი კლასიდან.
        // 12 - ინტერფეისი არის მეოდების ერთობლიობა რომელიც კლასმა უნდა განახორციელოს, ხოლო აბსტრაქტულ კლასს აქვს როგორც private ისე public მეთოდებიც უბრალოდ მას არ შეუძლია რომ დამოუკიდებელი იყოს და ის უნდა გაფართოვდეს ქვე-კლასით.
        // 13
//        Human human = new Human();
//        human.sayHello();
//        human.run();
//        human.jump();
//        human.sayBye();
        // 14 ა
        // 15
//        System.out.println("Enter first number: ");
//        double num1 = scanner.nextDouble();
//
//        System.out.println("Enter operation (+; -; *; /)");
//        char operation = scanner.next().charAt(0);
//
//        System.out.println("Enter second number: ");
//        double num2 = scanner.nextDouble();
//
//        double result = 0;
//
//        switch(operation){
//            case '+':
//            result = num1+num2;
//            break;
//            case '-':
//                result = num1-num2;
//                break;
//            case '*':
//                result = num1*num2;
//                break;
//            case '/':
//                result = num1/num2;
//                break;
//
//            default:
//                System.out.println("Invalid operator");
//                return;
//        }
//        System.out.println("Result is: " + result);
        // 16
//        char[] charArray = {'H', 'e', 'l', 'l', 'o', ' ', 'W', 'o', 'r', 'l', 'd'};
//        String result = "";
//        for(int i = charArray.length - 1; i < charArray.length; i--){
//            result += charArray[i];
//
//        }
//        System.out.println(result);
        // 18
//        int[] nums = {2, 7, 11, 15};
//        int target = 9;
//
//        int[] result = findTwoSum(nums, target);
//
//        if (result != null) {
//            System.out.println("Sum is" + target +  "of this two elements from nums array"+ result[0] + ", " + result[1] );
//        } else {
//            System.out.println("No solution found.");
//        }
//        return nums;
//    }
//    public static int[] findTwoSum(int[] nums, int target) {
//        for (int i = 0; i < nums.length - 1; i++) {
//            for (int j = i + 1; j < nums.length; j++) {
//                if (nums[i] + nums[j] == target) {
//                    return new int[] {i, j};
//                }
//            }
//        }
//        return null;

    }
}
